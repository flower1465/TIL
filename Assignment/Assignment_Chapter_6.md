# Chapter 6

1. 데이터 타입

   데이터 타입이란 프로그래밍 언어에서 사용할 수 있는 데이터(숫자, 문자열, 불리언 등)의 종류를 말한다.

   데이터 타입은 한정된 메모리 공간을 효율적으로 사용하기 위해서, 그리고 2진수 데이터로 메모리에 저장된 데이터를다양한 형태로 사용하기 위해 존재한다.

   **원시 타입** - 원시 타입의 값은 변경 불가능한 값이며 pass-by-value(값에 의한 전달)이다.

   JS는 독특하게 하나의 숫자 타입만 존재한다.

   JS의 숫자 타입은 **모든 수를 실수 처리**한다. 정수로 표시된다해도 사실은 실수다.

   Infinty: **양의 무한대** -Infinty:음의 무한대 NaN:**산술 연산 불가** 이 특별한 3가지 값들도 표현할 수 있다.

   JS의 **문자열은** 원시 타입이며 변경 불가능하다. 

   **문자열은 배열처럼 인덱스를 통해 접근할 수 있다.** 이런 특성을 갖는 데이터를 유사 배열이라한다

   문자열을 변경하는 것은 불가능 하지만 새로운 문자열을 재할당 하는 것은 가능하다. 

   **불리언 타입**의 값은 **true, false** 뿐이다. null, undefined 숫자 0은 false로 간주된다.

   **undefined**는 undefined가 유일하다 선언 이후 값을 할당하지 않은 변수는 해당 값을 가진다.

   **null** 또한 null이 유일하다. null과 NULL은 다르다. 의도적으로 변수에 값이 없다는 것을 명시할 때 사용한다. 또는 함수가 호출되었으나 유효한 값을 반환할 수 없는 경우 명시적으로 반환하기도 한다. null 타입을 확인할 때 typeof 연산자를 사용하면 object가 나온다 JS설계상의 오류이기 때문에 일치 연산자(==)을 사용해야 한다.

   **symbol**은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용한다. 심볼은 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.

   객체는 데이터와 그 데이터에 관련한 동작(절차,방법,기능)을 모두 포함할 수 있는 개념적 존재이다. 달리말해, 이름과 값을 가지는 데이터를 의미하는 프로퍼티와 동작을 의미하는 메소드를 포함할 수 있는 독립적 주체이다.

2. 변수

   **변수명** - 변수에 명시한 고유한 식별자

   변수값 - 변수로 참조할 수 있는 데이터

   변수는 var, let, const 키워드를 사용하여 선언한다.

   식별자인 변수명을 사용해 변수에 저장된 값을 참조한다.

   변수는 애플리케이션에서 한번 쓰고 버리는 값이 아닌 일정 기간 유지할 필요가 있는 값에 사용한다.

   변수의 존재 목적을 수비게 이해할 수 있도록 의미있는 변수명을 지정하여야한다.	

   var 키워드로 선언한 변수는 중복 선언이 가능하다.

   **동적 타이핑** - 변수의 타입 지정없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정되는 것 따라서 같은 변수에 여러 타입의 값을 할당할 수 있다.

   JS의 특징중 하나로 모든 선언문은 호이스팅된다.

   **호이스팅** - var 선언문이나 function선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성 즉 JS는 모든 선언문(var, let, const,function,class)이 선언되기 이전에 참조 가능하다.

   **변수의 생성 3단계**

   ​	**선언 단계(Declaration phase)**

   ​		변수 객체에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.

   ​	**초기화 단계(Initialization phase)**

   ​		변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다

   ​	**할당 단계(Assignment phase)**

   ​		undefined로 초기화된 변수에 실제값을 할당한다.

   var 키워드로 선언된 변수는 선언과 초기화가 한번에 이루어진다. 즉 스코프에 등록되고 메모리를 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 **호이스팅(Variable Hoisting)**이라한다.

   JS의 변수는 블록 레벨 스코프를 가지지 않고 함수 레벨 스코프를 갖는다. 단 **let const**를 사용하면 블록 레벨 스코프를 사용할 수 있다.

   **함수 레벨 스코프(Function-level scope)**

   함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

   **블록 레벨 스코프(Block-level scope)**

   코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.

   var 키워드의 문제점 

   함수 레벨 스코프 (전역 변수의 남발)

   var 키워드 생략 허용 (의도하지 않은 변수의 전역화)

   중복 선언 허용 (의도하지 않은 변수값 변경)

   변수 호이스팅 (변수를 선언하기 전에 참조가 가능하다)